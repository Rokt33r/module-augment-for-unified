declare namespace unified {
  interface Processor {
    (): Processor

    use(plugin: Plugin): Processor
    // We should discard if we're going to adopt module augmentation.
    // Otherwise, types from module augmentation won't work because they are sub types of `(plugin: Plugin<Settings>, options?: Settings): Processor` when we don't provide Generic.
    // use<T = Settings>(plugin: Plugin<T>, options?: T): Processor
    use(preset: Preset): Processor
    use<T = Settings>(pluginTuple: PluginTuple<T>): Processor
    use(list: PluggableList): Processor

  }

  type Plugin<T = Settings> = Attacher<T>
  type Settings = {
    [key: string]: unknown
  }

  interface Preset {
    plugins?: PluggableList
    settings?: Settings
  }
  type PluginTuple<T = Settings> = [Plugin<T>, T]
  type Pluggable<T = Settings> = Plugin<T> | Preset | PluginTuple<T>
  type PluggableList = Array<Pluggable<any>>

  interface Attacher<T = Settings> {
    (this: Processor, options?: T): Transformer | void
  }

  interface Transformer {
  }
}

declare function unified(): unified.Processor
export = unified